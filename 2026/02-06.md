# TIL（2026/02/06）— 配列と繰り返し処理（for）＋配列を作る関数

## 今日の学び（要点）
### 配列（Array）
- **複数の値をひとまとまりで扱う**ための仕組み
- **1つの名前で複数の値**（要素）を管理できる  
  例：`nums[1]`, `nums[2]` … のように番号（要素番号/添字）でアクセスする

### 繰り返し処理（for）
- 同じ処理を何度も実行するための仕組み
- 繰り返しには「繰り返し用の変数」が必要（例：`i`）
- 基本はこの3点セット：
  - **初期値**（どこから始めるか）
  - **条件式**（いつまで続けるか）
  - **繰り返しごとに行う処理**（増やす/減らすなど）

---

## 例1：配列を逆順にコピーする（rev_nums を作る）
### 目的
- `nums = {1,2,3,4,5,6}` を逆順にして `rev_nums = {6,5,4,3,2,1}` を作る

### 擬似コード（理解ポイント付き）
- `n ← numsの要素数`（今回は n=6）
- `rev_nums ← {n個の未定義の値}`（入れ物を先に用意）
- `for (i を n から 1 まで 1 ずつ減らす)`  
  → i=6,5,4,3,2,1 と動く
- `rev_nums[n-i+1] ← nums[i]`  
  → `n-i+1` によって、rev_nums側は 1,2,3,… と順番に埋まる

### 実際の対応（n=6）
- i=6 → rev_nums[1] ← nums[6]=6
- i=5 → rev_nums[2] ← nums[5]=5
- i=4 → rev_nums[3] ← nums[4]=4
- i=3 → rev_nums[4] ← nums[3]=3
- i=2 → rev_nums[5] ← nums[2]=2
- i=1 → rev_nums[6] ← nums[1]=1

---

## 例2：関数 makeNewArray（累積和の配列を作る）
### 関数の動き
- 入力配列 `in` を受け取り、出力配列 `out` を返す
- `out` は **inの先頭からの累積和（足し上げ）** になる

### プログラムのポイント
- 最初に `out` に `in[1]` を入れる
- その後、`tail`（outの末尾）を使って、次の値を作る  
  - `tail ← out[outの要素数]`
  - `outの末尾に (tail + in[i]) を追加`

---

## 問題：makeNewArray({3, 2, 1, 6, 5, 4}) の戻り値 out の「要素番号5」は？
### 入力
- in = {3, 2, 1, 6, 5, 4}

### 手順（out を順番に作る）
- out = {}（空）
- out末尾に in[1]=3 を追加  
  → out = {3}

for i=2..6：
- i=2：tail=3 → 3+2=5 → out={3,5}
- i=3：tail=5 → 5+1=6 → out={3,5,6}
- i=4：tail=6 → 6+6=12 → out={3,5,6,12}
- i=5：tail=12 → 12+5=17 → out={3,5,6,12,17}
- i=6：tail=17 → 17+4=21 → out={3,5,6,12,17,21}

✅ **答え：要素番号5の値は 17**

---

## 今日のまとめ
- 配列は「1つの名前で複数の値」を扱える
- for文は「初期値・条件・更新」のセットで考える
- 逆順コピーは添字変換（例：`n-i+1`）がポイント
- makeNewArray は **累積和（prefix sum）** の配列を作る関数
